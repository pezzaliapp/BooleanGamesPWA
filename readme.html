<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>BooleanGamesPWA — Guida</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: Arial, Helvetica, sans-serif;
      line-height: 1.6;
      margin: 2rem auto;
      max-width: 900px;
      padding: 0 1rem;
      color: #222;
    }
    h1, h2, h3 { color: #0055a5; }
    code {
      background: #f4f4f4;
      padding: 2px 5px;
      border-radius: 4px;
      font-family: monospace;
    }
    pre {
      background: #f9f9f9;
      padding: 1rem;
      border-radius: 5px;
      overflow-x: auto;
      font-family: monospace;
    }
    a {
      color: #0055a5;
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
<article>
<h1>BooleanGamesPWA — Imparare la logica come giocare con i LEGO

👉 Gioca subito online: <https://www.alessandropezzali.it/BooleanGamesPWA/>

BooleanGamesPWA trasforma la logica booleana in sei mini-giochi.  
Pensa alla logica come ai LEGO: pochi pezzi semplici (1/0, vero/falso) che, incastrati, costruiscono cose potenti.  
Non servono conoscenze pregresse: clicca, prova, osserva. L’obiettivo è coltivare la capacità di imparare ad imparare.

---

<h2>🧭 Come iniziare (subito)
<br>• Apri il link sopra e scegli un gioco dal menu.<br>• Ogni gioco ha pulsanti Nuovo / Hint / Check / Soluzione (quando presenti) e un feedback immediato.<br>• Se qualcosa sembra “non cambiarsi”, aggiorna la pagina con Cmd+Shift+R (macOS) o Ctrl+F5 (Windows).

---

<h2>🧱 Legenda completa dei simboli (i nostri “LEGO”)

<h3> Valori logici

<pre>| Notazione | Significato | Metafora |</pre>
|---|---|---|
<pre>| <code>1<code>, vero, true | acceso | lampadina accesa |
| <code>0<code>, falso, false | spento | lampadina spenta |</pre>

<h3> Variabili<br>• A, B, C, D: interruttori che possono valere 0 o 1.

<h3> Operatori (con verità-table)

> Nelle tabelle: 1=vero, 0=falso

NOT (negazione) — <code>¬X<code>  
Inverte il valore.

<pre>| X | ¬X |</pre>
|---|---|
<pre>| 0 | 1 |
| 1 | 0 |</pre>

AND (e logico) — <code>X ∧ Y<code>  
Vero solo se entrambi sono veri.

<pre>| X | Y | X ∧ Y |</pre>
|---|---|---|
<pre>| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |</pre>

OR (o logico) — <code>X ∨ Y<code>  
Vero se almeno uno è vero.

<pre>| X | Y | X ∨ Y |</pre>
|---|---|---|
<pre>| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 1 |</pre>

XOR (o esclusivo) — <code>X ⊕ Y<code>  
Vero se esattamente uno è vero.

<pre>| X | Y | X ⊕ Y |</pre>
|---|---|---|
<pre>| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |</pre>

Implica — <code>X → Y<code>  
Falso solo se X=1 e Y=0; altrimenti vero.

<pre>| X | Y | X → Y |</pre>
|---|---|---|
<pre>| 0 | 0 | 1 |
| 0 | 1 | 1 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |</pre>

Suggerimenti di lettura<br>• Priorità tipica: <code>¬<code> > <code>∧<code> > <code>∨<code> > <code>⊕<code> > <code>→<code>.  <br>• Usa parentesi per evitare ambiguità, es.: <code>(A ∧ B) → ¬C<code>.

<h3> Mappe di Karnaugh (K-map) — etichette in Gray code<br>• 3 variabili (A; BC in colonne): colonne ordinate 00, 01, 11, 10  <br>• 4 variabili (AB righe; CD colonne): righe 00, 01, 11, 10 e colonne 00, 01, 11, 10  
> Il Gray code cambia un solo bit alla volta tra celle adiacenti: utile per “vedere” pattern.

---

<h2>🎮 I giochi (istruzioni + esempio + obiettivo didattico)

<h3> 1) 🧮 Verità o Falso — Valutare una formula
Obiettivo: decidere se una formula è vera o falsa con i valori dati.

Come si gioca
1. Click Nuovo (appare una formula e un’assegnazione di A,B,C).  
2. Sostituisci i valori nella formula.  
3. Valuta passo passo (usa la legenda sopra).  
4. Premi Vero o Falso.  
5. Hint mostra la formula annotata con 0/1.

Esempio
<pre>
Formula: (A ∧ B) → ¬C
Valori:  A=1, B=0, C=1

(1 ∧ 0) = 0
¬C = ¬1 = 0
(0 → 0) = 1 ⇒ Vero
<pre>

Cosa impari: lettura, sostituzione, valutazione — la “grammatica” della logica.

---

<h3> 2) 🗺️ K-map (3 variabili) — Vedere la funzione su una mappa
Obiettivo: riempire la griglia 2×4 (A; BC) con 0/1 per matchare la funzione mostrata.

Come si gioca
1. Nuovo → funzione casuale (es. <code>A ∧ C<code>).  
2. Clicca le celle per impostare 0/1.  
3. Check mostra quante celle coincidono.  
4. Hint corregge una cella. Soluzione compila tutto. Pulisci resetta.

Esempio<br>• Funzione <code>A ∧ C<code> → metti 1 in tutte le celle dove A=1 e C=1 (secondo le etichette A/BC della griglia).  

Cosa impari: trasformare una formula astratta in una mappa visiva.

---

<h3> 3) 🧩 SAT 3-CNF — Rendere vere tutte le clausole
Obiettivo: trovare A,B,C che rendano tutte le clausole vere.

Come si gioca
1. Nuovo → elenco di clausole tipo <code>(A ∨ ¬B ∨ C)<code>.  
2. Attiva/disattiva i checkbox A, B, C.  
3. Le clausole diventano verdi quando soddisfatte.  
4. Hint imposta automaticamente una variabile corretta. Reset azzera.

Esempio<br>• Clausole: <code>(A ∨ ¬B ∨ C)<code>, <code>(¬A ∨ C ∨ B)<code>  <br>• Prova A=1, B=0, C=1 → entrambe vere → risolto.

Cosa impari: problem solving con tentativi informati (osserva il feedback).

---

<h3> 4) 🗺️ K-map (4 variabili) — Stesse regole, scala maggiore
Obiettivo: riempire la griglia 4×4 (AB; CD) secondo la funzione data.

Come si gioca
1. Nuovo → funzione su A,B,C,D.  
2. Clicca le celle 0/1.  
3. Usa Check / Hint / Soluzione / Pulisci come guida.

Esempio<br>• Funzione <code>B ∨ D<code> → metti 1 dove B=1 o D=1 (riga/colonna in Gray).

Cosa impari: generalizzazione e riconoscimento di pattern più estesi.

---

<h3> 5) 🧠 Quine–McCluskey — Semplificare (pensiero essenziale)
Obiettivo: ridurre una funzione alla forma minima.

Come si gioca
1. Nuovo (3 o 4 variabili) → appaiono i minterms.  
2. Mostra passaggi → vedi gruppi, implicanti primi, essenziali, copertura minima.  
3. Leggi la formula minimale.

Esempio (2 variabili)<br>• Vera nei casi 01 e 11 → espressione completa: <code>(¬A ∧ B) ∨ (A ∧ B)<code>  <br>• Forma minima: <code>B<code> (se B=1, il risultato è 1 indipendentemente da A).

Cosa impari: togliere il superfluo, capire la struttura.

---

<h3> 6) 🔌 Circuiti logici — Costruire con blocchi (AND/OR/NOT/XOR)
Obiettivo: comporre porte logiche, osservare l’uscita e la tabella di verità in tempo reale.

Come si gioca
1. +AND/OR/NOT/XOR → crea un blocco (es. G1).  
2. Imposta gli ingressi del blocco (A/B/C/D o l’uscita di un altro blocco).  
3. In basso scegli Output osservato (es. G1).  
4. Attiva/spegni A/B/C/D → aggiornamento live di uscita e tabella.  
5. Reset pulisce tutto.

Esempio<br>• G1 = AND(A, B)  <br>• Con A=1 e B=1 → uscita=1; se uno è 0 → uscita=0.  <br>• Aggiungi G2 = XOR(G1, C) → componi logiche più ricche.

Cosa impari: dal simbolo al circuito, pensiero compositivo.

---

<h2>🛣️ Percorsi consigliati (per tutti i livelli)
<br>• Principiante (15–20 min) → Verità o Falso → SAT  <br>• Pratico (30 min) → K-map 3v → K-map 4v  <br>• Curioso/Avanzato (45–60+ min) → Quine–McCluskey → Circuiti

---

<h2>❓ FAQ rapide
<br>• Non capisco i simboli.  
  Guarda la Legenda sopra e le tabelle di verità: sono il tuo “foglio di comandi”.
<br>• La pagina non si aggiorna.  
  Fai Cmd+Shift+R (macOS) o Ctrl+F5 (Windows). Su sito HTTPS il service worker aggiorna in automatico, ma a volte serve un hard refresh.
<br>• Posso usarlo in classe?  
  Sì. Proposta: 10′ di Verità/Falso condiviso, poi gruppi su K-map, chiusura con un circuito semplice costruito insieme.

---

<h2>📚 Glossario essenziale
<br>• Variabile: interruttore che vale 0/1.  <br>• Funzione: regola che, dati gli interruttori, produce 0/1.  <br>• Minterm: combinazione specifica di variabili per cui la funzione vale 1.  <br>• K-map: mappa che mostra dove la funzione vale 1 (etichette in Gray).  <br>• Implicante primo / essenziale: “blocchi” indispensabili nella forma minima.  <br>• Forma minima: modo più corto e chiaro di scrivere la stessa funzione.

---

<h2>🧾 Licenza

Software rilasciato con licenza MIT.  
Se insegni, traduci, migliori: condividi. La cultura cresce se si costruisce insieme, un mattoncino alla volta.
</article>
</body>
</html>